/* 
Rotator cuff recovery 
@RoniBandini, March 2022, Argentina
Edge Impulse and Arduino BLE 33 Sense 
Oled Screen VCC to Arduino 3.3v, GND to Arduino GND, SDA to A4, SCL to A5
*/

/* Includes ---------------------------------------------------------------- */
#include <Rotator_cuff_inferencing.h>
#include <Arduino_LSM9DS1.h>

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128  
#define SCREEN_HEIGHT 32  
#define OLED_RESET     -1  
#define SCREEN_ADDRESS 0x3C  
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define imageWidthLogo 128
#define imageHeightLogo 32

const unsigned char logo [] PROGMEM ={
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x80, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x3f, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x07, 0xff, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x1f, 0xf8, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x7c, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x70, 0x00, 0x00, 
  0x3f, 0x07, 0x1f, 0xce, 0x7f, 0x9e, 0x3f, 0x00, 0xf3, 0x8c, 0xfd, 0xf8, 0x00, 0xe0, 0x00, 0x00, 
  0x3f, 0x9f, 0xdf, 0xcf, 0x7f, 0x9f, 0x3f, 0x81, 0xf1, 0x8e, 0xfd, 0xf8, 0x01, 0xc0, 0x00, 0x00, 
  0x3f, 0x9f, 0xdf, 0xce, 0x7f, 0xbf, 0x1f, 0x81, 0xfb, 0x9d, 0xfd, 0xf8, 0x01, 0x80, 0x00, 0x00, 
  0x19, 0xdd, 0xdf, 0xef, 0x7f, 0xf3, 0xb9, 0xc3, 0x9d, 0x8c, 0xc1, 0x80, 0x01, 0x80, 0x00, 0x00, 
  0x39, 0xb8, 0xe7, 0x0f, 0x0c, 0x71, 0x99, 0x83, 0x9d, 0x8d, 0xc1, 0x80, 0x01, 0x80, 0x00, 0x00, 
  0x19, 0xd8, 0xc7, 0x1f, 0x0c, 0x71, 0xb9, 0xc2, 0x9f, 0x8c, 0xc1, 0x80, 0x01, 0x80, 0x00, 0x00, 
  0x3f, 0xb8, 0xc3, 0x1b, 0x0c, 0x63, 0xbf, 0x83, 0x01, 0x8d, 0xfd, 0xf8, 0xf1, 0x80, 0x30, 0x00, 
  0x1f, 0xb0, 0xe6, 0x1f, 0x9c, 0x71, 0xbf, 0x83, 0x83, 0x9c, 0xf9, 0xf0, 0xe1, 0x80, 0x30, 0x00, 
  0x3f, 0x38, 0xc7, 0x19, 0x8c, 0x61, 0x9f, 0x03, 0x01, 0x8d, 0xfd, 0xf8, 0x03, 0x80, 0x38, 0x00, 
  0x1b, 0x38, 0xc7, 0x1b, 0x8c, 0x73, 0xdb, 0x03, 0x8d, 0x8c, 0xc1, 0x80, 0x03, 0x80, 0x18, 0x00, 
  0x3b, 0x98, 0xe7, 0x3f, 0x9c, 0x73, 0xbb, 0x83, 0x9d, 0x9c, 0xc1, 0x80, 0x03, 0x00, 0x18, 0x00, 
  0x3b, 0x99, 0xc3, 0x3f, 0xcc, 0x73, 0xab, 0x81, 0x9d, 0xdd, 0xc1, 0xc0, 0x03, 0x00, 0x18, 0x00, 
  0x19, 0x9f, 0xc7, 0x1f, 0x8e, 0x3f, 0x39, 0x81, 0xf9, 0xfc, 0xc1, 0x80, 0x03, 0x00, 0x18, 0x00, 
  0x19, 0xdf, 0x87, 0x31, 0xcc, 0x1f, 0x39, 0xc1, 0xf8, 0xf8, 0xc1, 0x80, 0x07, 0x00, 0x1c, 0x00, 
  0x39, 0xcf, 0x03, 0x31, 0xdc, 0x1c, 0x19, 0xc0, 0xe0, 0x70, 0xc1, 0x80, 0x03, 0x00, 0x18, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x18, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3c, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x3e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x3f, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x73, 0x80, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x21, 0x00
};


const unsigned char edge [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x0b, 0xb6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x92, 0x40, 0x0f, 0xe7, 0xc0, 0x78, 0xfe, 0x0c, 0x40, 0x8f, 0x84, 0x11, 0x01, 0xf1, 0xfc, 
  0x08, 0x00, 0x10, 0x07, 0xe7, 0xe1, 0xfc, 0xfe, 0x0c, 0xe1, 0xdf, 0xee, 0x3b, 0x03, 0xf9, 0xf8, 
  0x00, 0x00, 0x00, 0x0c, 0x06, 0x31, 0x80, 0x40, 0x0e, 0xe3, 0x88, 0xe6, 0x33, 0x83, 0x01, 0x80, 
  0x04, 0x80, 0x00, 0x0c, 0x06, 0x3b, 0x00, 0xc0, 0x04, 0x73, 0xdc, 0x6c, 0x33, 0x03, 0x81, 0x80, 
  0x02, 0x34, 0x50, 0x0f, 0xc6, 0x1b, 0x0c, 0xfc, 0x0c, 0xf7, 0x98, 0x6e, 0x33, 0x01, 0xf1, 0xf8, 
  0x02, 0x92, 0x08, 0x0f, 0xc6, 0x33, 0x3c, 0xfc, 0x0c, 0x7e, 0x8f, 0xc4, 0x33, 0x80, 0x79, 0xf0, 
  0x00, 0x00, 0x00, 0x04, 0x06, 0x1b, 0x8c, 0xc0, 0x0c, 0xdd, 0xdf, 0x8e, 0x33, 0x00, 0x19, 0x80, 
  0x00, 0x00, 0x00, 0x0d, 0x26, 0xf1, 0xce, 0x60, 0x0e, 0xc5, 0x98, 0x07, 0x73, 0x42, 0x99, 0x88, 
  0x15, 0x28, 0xa4, 0x0f, 0xe7, 0xe0, 0xfc, 0xfe, 0x0c, 0xc1, 0x9c, 0x03, 0xf3, 0xfb, 0xf9, 0xfc, 
  0x0d, 0xae, 0xb6, 0x06, 0xc5, 0x40, 0x50, 0x7a, 0x04, 0xc0, 0x80, 0x01, 0x41, 0x51, 0xa1, 0xb0, 
  0x12, 0x92, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x06, 0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define CONVERT_G_TO_MS2    9.80665f
static bool debug_nn = false;  
static uint32_t run_inference_every_ms = 400;
static rtos::Thread inference_thread(osPriorityLow);
static float buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE] = { 0 };
static float inference_buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];

void run_inference_background();

int counterRight=0;
int counterLeft=0;
int counterUp=0;
int rightLimit=10;
int leftLimit=10;
int upLimit=5;
int myCounter=1;
int updateScreen=0;
String lastPrediction="Idle";

void setup()
{

    Serial.begin(115200);
    Serial.println("Rotator Cuff Recovery - Roni Bandini");

    if (!IMU.begin()) {
        ei_printf("Failed to initialize IMU!\r\n");
    }
    else {
        ei_printf("IMU initialized\r\n");
    }

    if (EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME != 3) {
        ei_printf("ERR: EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME should be equal to 3 (the 3 sensor axes)\n");
        return;
    }

     if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
        Serial.println(F("SSD1306 allocation failed"));
        for(;;); // Don't proceed, loop forever
    }

    display.display();
    delay(1000); 
    display.clearDisplay();   
    display.drawBitmap(0, 0,  logo, imageWidthLogo, imageHeightLogo, 1); 
    display.display();   
    delay(2000);

    display.clearDisplay();   
    display.drawBitmap(0, 0,  edge, imageWidthLogo, imageHeightLogo, 1); 
    display.display();   
    delay(2000);

    display.clearDisplay();
    display.setTextSize(1);            
    display.setTextColor(SSD1306_WHITE); 
    display.println("Rotator Cuff Recovery");
    display.println("Arduino BLE33 TinyML"); 
    display.println("@RoniBandini 3/22"); 
    display.println("Device ready..."); 
    display.display();
    delay(2000); 

    inference_thread.start(mbed::callback(&run_inference_background));
}


void ei_printf(const char *format, ...) {
   static char print_buf[1024] = { 0 };

   va_list args;
   va_start(args, format);
   int r = vsnprintf(print_buf, sizeof(print_buf), format, args);
   va_end(args);

   if (r > 0) {
       Serial.write(print_buf);
   }
}


void run_inference_background()
{
    
    
    // wait until we have a full buffer
    delay((EI_CLASSIFIER_INTERVAL_MS * EI_CLASSIFIER_RAW_SAMPLE_COUNT) + 100);

    // This is a structure that smoothens the output result
    // With the default settings 70% of readings should be the same before classifying.
    ei_classifier_smooth_t smooth;
    ei_classifier_smooth_init(&smooth, 10 /* no. of readings */, 7 /* min. readings the same */, 0.65 /* min. confidence */, 0.3 /* max anomaly */);

    while (1) {
        // copy the buffer
        memcpy(inference_buffer, buffer, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE * sizeof(float));

        // Turn the raw buffer in a signal which we can the classify
        signal_t signal;
        int err = numpy::signal_from_buffer(inference_buffer, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);
        if (err != 0) {
            ei_printf("Failed to create signal from buffer (%d)\n", err);
            return;
        }

        // Run the classifier
        ei_impulse_result_t result = { 0 };

        err = run_classifier(&signal, &result, debug_nn);
        if (err != EI_IMPULSE_OK) {
            ei_printf("ERR: Failed to run classifier (%d)\n", err);
            return;
        }

        // print the predictions
        ei_printf("Predictions ");
        ei_printf("(DSP: %d ms., Classification: %d ms., Anomaly: %d ms.)",
            result.timing.dsp, result.timing.classification, result.timing.anomaly);
        ei_printf(": ");

        // ei_classifier_smooth_update yields the predicted label
        const char *prediction = ei_classifier_smooth_update(&smooth, &result);
        ei_printf("%s ", prediction);
        
        if (prediction=="Right" and prediction!=lastPrediction){
              
              counterRight=counterRight+1; 
              updateScreen=1;
              
          }
         
        if (prediction=="Left" and prediction!=lastPrediction){
          
            counterLeft=counterLeft+1;   
            updateScreen=1;
               
         }

         if (prediction=="Up" and prediction!=lastPrediction){
          
            counterUp=counterUp+1;   
            updateScreen=1;
               
         }
       
         lastPrediction=prediction;

         if (updateScreen==1){
          
              display.clearDisplay();
              display.setCursor(0, 0); 
              display.println("Rotator Cuff Mobility");
              display.print("Right : ");

              myCounter=1;
              
              while (myCounter<=rightLimit){

                if (myCounter<counterRight) {
                  display.print("*");
                  }
                else {
                  display.print("_");
                  }
                myCounter++;
                }
              display.print("\r\n");  
                
              display.print("Left  : ");

              myCounter=1;
              
              while (myCounter<=leftLimit){

                if (myCounter<counterLeft) {
                  display.print("*");
                  }
                else {
                  display.print("_");
                  }
                myCounter++;
                }
              display.print("\r\n"); 
                       
              display.print("Up    : ");  

              myCounter=1;
              
              while (myCounter<=upLimit){

                if (myCounter<counterUp) {
                  display.print("*");
                  }
                else {
                  display.print("_");
                  }
                myCounter++;
                }
              display.print("\r\n");
              
              display.display();

              updateScreen=0;
          }

        if (counterRight>=rightLimit and counterLeft>=leftLimit and counterUp>=upLimit){
              
              display.clearDisplay();
              display.setCursor(0, 0); 
              display.println("Rotator Cuff Recovery");             
              display.println("Good work :)");         
              display.println("You are done for today.");         
              
              for(;;); // Don't proceed, loop forever
          
          }  
         
         ei_printf("Right (%d)", counterRight);
         ei_printf("Left (%d)", counterLeft);
         ei_printf("Up (%d)", counterUp);
                        
        ei_printf("]\n");

        delay(run_inference_every_ms);
    }

    ei_classifier_smooth_free(&smooth);
    
}

/**
* @brief      Get data and run inferencing
*
* @param[in]  debug  Get debug info if true
*/
void loop()
{
    while (1) {
        // Determine the next tick (and then sleep later)
        uint64_t next_tick = micros() + (EI_CLASSIFIER_INTERVAL_MS * 1000);

        // roll the buffer -3 points so we can overwrite the last one
        numpy::roll(buffer, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, -3);

        // read to the end of the buffer
        IMU.readAcceleration(
            buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 3],
            buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 2],
            buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 1]
        );

        buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 3] *= CONVERT_G_TO_MS2;
        buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 2] *= CONVERT_G_TO_MS2;
        buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE - 1] *= CONVERT_G_TO_MS2;

        // and wait for next tick
        uint64_t time_to_wait = next_tick - micros();
        delay((int)floor((float)time_to_wait / 1000.0f));
        delayMicroseconds(time_to_wait % 1000);
    }
}

#if !defined(EI_CLASSIFIER_SENSOR) || EI_CLASSIFIER_SENSOR != EI_CLASSIFIER_SENSOR_ACCELEROMETER
#error "Invalid model for current sensor"
#endif
